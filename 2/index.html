<!DOCTYPE html>

<html>

<head>
    <title>Project 1</title>
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
            margin: 20px;
        }
    </style>
</head>

<body>
    <style>
      body {
        background-color: rgb(163, 168, 173); 
      }
    </style>

    <h1>Project 2</h1>
    <h2>Fun with Filters and Frequencies</h2>
    <div></div>
    <h3>Part 1.1</h3>
    <p>For this part I implemented two types of custom convolution functions: one naive function, and one numpy vectorized 
      function. I then compared the performance of each version with the scipy convolve2d function and found the library function to be vastly
      more efficient (as expected). Below are sample photos and snippets of the code used:
    </p>
    <h4>Code</h4>
    <p><pre><code>
#Naive Convolution
def myconvolve_naive(image, kernel):
    h_kern, w_kern = kernel.shape
    kernel = np.flip(kernel)

    #padding 
    pad_top = (h_kern - 1) // 2
    pad_bottom = (h_kern - 1) - pad_top
    pad_left = (w_kern - 1) // 2
    pad_right = (w_kern - 1) - pad_left
    paddingdims = ((pad_top, pad_bottom), (pad_left, pad_right))
    padded = np.pad(image, paddingdims, mode='constant', constant_values=0)
    h_im, w_im = padded.shape

    output = np.zeros((int(h_im - h_kern + 1), int(w_im - w_kern + 1)))
    h_out, w_out = output.shape

    for row in range(h_out):
        for col in range(w_out):

            outputval = 0
            
            for kernr in range(h_kern):
                for kernc in range(w_kern):
                    imval = padded[row + kernr, col + kernc]
                    kernval = kernel[kernr, kernc]
                    outputval += imval * kernval

            output[row, col] = outputval
    return output

#Optimized convoluton (Inspired by CS 189 HW6.2)
def myconvolve(image, kernel):
    h_kern, w_kern = kernel.shape
    kernel = np.flip(kernel)

    #padding 
    pad_top = (h_kern - 1) // 2
    pad_bottom = (h_kern - 1) - pad_top
    pad_left = (w_kern - 1) // 2
    pad_right = (w_kern - 1) - pad_left
    paddingdims = ((pad_top, pad_bottom), (pad_left, pad_right))
    padded = np.pad(image, paddingdims, mode='constant', constant_values=0)
    h_im, w_im = padded.shape

    output = np.zeros((int(h_im - h_kern + 1), int(w_im - w_kern + 1)))
    h_out, w_out = output.shape

    for r in range(h_out):
        for c in range(w_out):
            rend = r + h_kern
            cend = c + w_kern

            output[r, c] = np.sum(padded[r:rend, c:cend] * kernel)

    return output
    </code></pre></p>
    <h4>Pictures</h4>


    <h4>Runtimes</h4>
    Naive Time: 17.15 seconds
    Optimized time: 14.37 seconds
    Library time: 0.11 Seconds


    <h3>Part 1.2</h3>
    
</body>